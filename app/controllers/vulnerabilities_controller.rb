class VulnerabilitiesController < ApplicationController
  before_filter :authentication_check, :only => [:edit, :update, :destroy]
  
  # GET /vulnerabilities
  # GET /vulnerabilities.json
  def index 
    @vulnerabilities = Vulnerability.all.page params[:page]
    @hash = get_user_hash
    respond_to do |format|
      format.html do
        if request.xhr?
          render partial: "vulnerability", collection: @vulnerabilities , layout: false
        else
          format.html
        end
      end

      format.json { render json: @vulnerabilities }
    end
  end

  # GET /vulnerabilities/1
  # GET /vulnerabilities/1.json
  def show
    @vulnerability = Vulnerability.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @vulnerability }
    end
  end

  # GET /vulnerabilities/new
  # GET /vulnerabilities/new.json
  def new
    @vulnerability = Vulnerability.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @vulnerability }
    end
  end

  # GET /vulnerabilities/1/edit
  def edit
    @vulnerability = Vulnerability.find(params[:id])
  end

  # POST /vulnerabilities
  # POST /vulnerabilities.json
  def create
    @vulnerability = Vulnerability.new(params[:vulnerability])

    respond_to do |format|
        # if verify_recaptcha(:model => @vulnerability, :message => "Oh! It's error with reCAPTCHA!") && @vulnerability.save
        if verify_recaptcha() && @vulnerability.save
        format.html { redirect_to @vulnerability, notice: 'Vulnerability was successfully created.' }
        format.json { render json: @vulnerability, status: :created, location: @vulnerability }
      else
        format.html { render action: "new" }
        format.json { render json: @vulnerability.errors, status: :unprocessable_entity }
      end
    end
  end

  # PUT /vulnerabilities/1
  # PUT /vulnerabilities/1.json
  def update
    @vulnerability = Vulnerability.find(params[:id])

    respond_to do |format|
      if @vulnerability.update_attributes(params[:vulnerability])
        format.html { redirect_to @vulnerability, notice: 'Vulnerability was successfully updated.' }
        format.json { head :ok }
      else
        format.html { render action: "edit" }
        format.json { render json: @vulnerability.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /vulnerabilities/1
  # DELETE /vulnerabilities/1.json
  def destroy
    @vulnerability = Vulnerability.find(params[:id])
    @vulnerability.destroy

    respond_to do |format|
      format.html { redirect_to vulnerabilities_url }
      format.json { head :ok }
    end
  end

  # GET /vulnerabilities/1/rate
  def rate
    vulnerability = Vulnerability.find(params[:id])
    hash = get_user_hash

    if vulnerability.ratings.where(userhash: hash).exists?  
      redirect_to vulnerabilities_url, notice: 'voted already' 
      return
    end

    vulnerability.rating += 1
    vulnerability.ratings.new(userhash: hash)
    vulnerability.save
    redirect_to vulnerabilities_url, notice: 'thanks for vote'

  end

  private
    def get_user_hash 
      require 'digest/md5'
      user_ip = request.remote_ip
      user_browser = request.env['HTTP_USER_AGENT']

      Digest::MD5.hexdigest( user_ip + user_browser )
    end
  
    def authentication_check
      authenticate_or_request_with_http_basic do |user_name, password|
        user_name == 'admin' && password == 'admin'
      end
    end
    
end
